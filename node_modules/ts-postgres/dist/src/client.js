"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("constants");
const net_1 = require("net");
const ts_typed_events_1 = require("ts-typed-events");
const defaults = require("./defaults");
const logger = require("./logging");
const queue_1 = require("./queue");
const query_1 = require("./query");
const result_1 = require("./result");
const protocol_1 = require("./protocol");
const types_1 = require("./types");
const utils_1 = require("./utils");
;
;
;
;
;
;
;
class Client {
    constructor(config = {}) {
        this.config = config;
        this.events = ts_typed_events_1.events({
            connect: new ts_typed_events_1.Event(),
            end: new ts_typed_events_1.Event(),
            parameter: new ts_typed_events_1.Event(),
            error: new ts_typed_events_1.Event(),
            notice: new ts_typed_events_1.Event(),
            notification: new ts_typed_events_1.Event()
        });
        this.ending = false;
        this.connected = false;
        this.connecting = false;
        this.ready = false;
        this.error = false;
        this.encoding = 'utf-8';
        this.stream = new net_1.Socket();
        this.buffer = null;
        this.expect = 5;
        this.mustDrain = false;
        this.offset = 0;
        this.remaining = 0;
        this.bindQueue = new queue_1.Queue();
        this.closeHandlerQueue = new queue_1.Queue();
        this.cleanupQueue = new queue_1.Queue();
        this.errorHandlerQueue = new queue_1.Queue();
        this.preFlightQueue = new queue_1.Queue();
        this.rowDescriptionQueue = new queue_1.Queue();
        this.parameterDescriptionQueue = new queue_1.Queue();
        this.nextPreparedStatementId = 0;
        this.activeDataHandlerInfo = null;
        this.closed = false;
        this.processId = null;
        this.secretKey = null;
        this.transactionStatus = null;
        const keepAlive = (typeof config.keepAlive === 'undefined') ?
            config.keepAlive : true;
        this.writer = new protocol_1.Writer(this.stream, this.encoding);
        this.stream.on('connect', () => {
            if (keepAlive) {
                this.stream.setKeepAlive(true);
            }
            ;
            this.closed = false;
            this.writer.startup(this.config.user || defaults.user || '', this.config.database || defaults.database || '', this.config.extraFloatDigits || 0);
        });
        this.stream.on('close', () => {
            this.ready = false;
            this.connected = false;
            this.mustDrain = false;
        });
        this.stream.on('drain', () => {
            this.mustDrain = false;
            this.flush();
        });
        this.stream.on('data', (buffer) => {
            const length = buffer.length;
            const remaining = this.remaining;
            const size = length + remaining;
            if (this.buffer && remaining) {
                const free = this.buffer.length - this.offset - remaining;
                let tail = this.offset + remaining;
                if (free < length) {
                    const newBuffer = Buffer.allocUnsafe(size);
                    this.buffer.copy(newBuffer, 0, this.offset, tail);
                    this.offset = 0;
                    this.buffer = newBuffer;
                    tail = remaining;
                }
                ;
                buffer.copy(this.buffer, tail, 0, length);
            }
            else {
                this.buffer = buffer;
                this.offset = 0;
            }
            try {
                const read = this.receive(this.buffer, this.offset, size);
                this.offset += read;
                this.remaining = size - read;
            }
            catch (error) {
                const active = this.activeDataHandlerInfo;
                if (active) {
                    active.handler(error);
                }
                while (!this.bindQueue.isEmpty()) {
                    const info = this.bindQueue.shift();
                    if (info) {
                        info.handler(error);
                    }
                }
                while (!this.preFlightQueue.isEmpty()) {
                    const handler = this.preFlightQueue.shift().dataHandler;
                    if (handler) {
                        handler(error);
                    }
                }
                // Mark connection as not connected.
                this.connected = false;
                this.ready = false;
                this.closed = true;
                this.error = true;
                this.stream.destroy(error);
            }
        });
        this.stream.on('error', (error) => {
            // Don't raise ECONNRESET errors - they can & should be
            // ignored during disconnect
            if (this.ending && error.errno === constants_1.ECONNRESET) {
                return;
            }
            this.events.end.emit({});
        });
        this.stream.on('finish', () => {
            this.closed = true;
            this.events.end.emit({});
        });
    }
    connect() {
        if (this.connecting) {
            throw new Error('Already connecting');
        }
        if (this.error) {
            throw new Error('Can\'t connect in error state');
        }
        this.connecting = true;
        let p = this.events.connect.once();
        const port = this.config.port || defaults.port;
        const host = this.config.host || defaults.host;
        if (host.indexOf('/') === 0) {
            this.stream.connect(host + '/.s.PGSQL.' + port);
        }
        else {
            this.stream.connect(port, host);
        }
        return p;
    }
    end() {
        if (this.closed) {
            throw new Error('Connection already closed.');
        }
        this.ending = true;
        this.writer.end();
        this.flush();
        this.stream.end();
        this.ready = false;
        return this.events.end.once();
    }
    on(event, callback) {
        switch (event) {
            case 'connect': {
                this.events.connect.on(callback);
                break;
            }
            case 'end': {
                this.events.end.on(callback);
                break;
            }
            case 'error': {
                this.events.error.on(callback);
                break;
            }
            case 'notice': {
                this.events.notice.on(callback);
                break;
            }
            case 'notification': {
                this.events.notification.on(callback);
                break;
            }
            case 'parameter': {
                this.events.parameter.on(callback);
                break;
            }
        }
    }
    prepare(text, name, types) {
        const providedNameOrGenerated = (name) || ((this.config.preparedStatementPrefix ||
            defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => reject(error);
            this.errorHandlerQueue.push(errorHandler);
            this.writer.parse(providedNameOrGenerated, text, types || []);
            this.writer.describe(providedNameOrGenerated, 'S');
            this.preFlightQueue.push({
                descriptionHandler: (description) => {
                    const types = this.parameterDescriptionQueue.shift();
                    this.cleanupQueue.shift(3 /* ParameterDescription */);
                    resolve({
                        close: () => {
                            return new Promise((resolve) => {
                                this.writer.close(providedNameOrGenerated, 'S');
                                this.closeHandlerQueue.push(resolve);
                                this.cleanupQueue.push(1 /* Close */);
                                this.writer.flush();
                                this.flush();
                            });
                        },
                        execute: (values, portal, format) => {
                            const result = result_1.makeResult();
                            result.nameHandler(description.names);
                            const info = {
                                handler: result.dataHandler,
                                description: description
                            };
                            this.bindAndExecute(info, {
                                name: providedNameOrGenerated,
                                portal: portal || '',
                                format: format || types_1.DataFormat.Binary,
                                values: values || [],
                                close: false
                            }, types);
                            return result.iterator;
                        }
                    });
                },
                dataHandler: null,
                bind: null
            });
            this.writer.sync();
            this.cleanupQueue.push(4 /* PreFlight */);
            this.cleanupQueue.push(3 /* ParameterDescription */);
            this.cleanupQueue.push(2 /* ErrorHandler */);
            this.flush();
        });
    }
    query(text, values, types, format) {
        const query = (typeof text === 'string') ?
            new query_1.Query(text, values, {
                types: types,
                format: format
            }) :
            text;
        return this.execute(query);
    }
    bindAndExecute(info, bind, types) {
        try {
            this.writer.bind(bind.name, bind.portal, bind.format, bind.values, types);
        }
        catch (error) {
            info.handler(error);
            return;
        }
        this.bindQueue.push(info);
        this.writer.execute(bind.portal);
        this.cleanupQueue.push(0 /* Bind */);
        if (bind.close) {
            this.writer.close(bind.name, 'S');
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Close */);
        }
        this.writer.sync();
        this.errorHandlerQueue.push((error) => { info.handler(error); });
        this.cleanupQueue.push(2 /* ErrorHandler */);
        this.flush();
    }
    execute(query) {
        if (this.closed && !this.connecting) {
            throw new Error('Connection is closed.');
        }
        const text = query.text;
        const values = query.values || [];
        const options = query.options;
        const format = options ? options.format : undefined;
        const types = options ? options.types : undefined;
        const portal = (options ? options.portal : undefined) || '';
        const result = result_1.makeResult();
        const descriptionHandler = (description) => {
            result.nameHandler(description.names);
        };
        if (values && values.length) {
            const name = (options ? options.name : undefined) || ((this.config.preparedStatementPrefix ||
                defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
            this.writer.parse(name, text, types || []);
            this.writer.describe(name, 'S');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: result.dataHandler,
                bind: {
                    name: name,
                    portal: portal,
                    format: format || types_1.DataFormat.Binary,
                    values: values,
                    close: true
                }
            });
            this.cleanupQueue.push(4 /* PreFlight */);
        }
        else {
            const name = (options ? options.name : undefined) || '';
            this.writer.parse(name, text);
            this.writer.bind(name, portal);
            this.bindQueue.push(null);
            this.writer.describe(portal, 'P');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: result.dataHandler,
                bind: null
            });
            this.writer.execute(portal);
            this.writer.close(name, 'S');
            this.cleanupQueue.push(0 /* Bind */);
            this.cleanupQueue.push(4 /* PreFlight */);
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Close */);
        }
        this.errorHandlerQueue.push((error) => result.dataHandler(error));
        this.cleanupQueue.push(2 /* ErrorHandler */);
        this.writer.sync();
        this.flush();
        return result.iterator;
    }
    flush() {
        if (!this.ready || this.mustDrain)
            return;
        if (this.writer.send())
            this.mustDrain = true;
    }
    parseError(buffer) {
        let level = null;
        let code = null;
        let message = null;
        const length = buffer.length;
        let offset = 0;
        while (offset < length) {
            let next = buffer.indexOf(0, offset);
            if (next < 0)
                break;
            const value = buffer.slice(offset + 1, next).toString();
            switch (buffer[offset]) {
                case 0x53: {
                    if (level === null) {
                        level = value;
                    }
                    break;
                }
                case 0x56: {
                    level = value;
                    break;
                }
                case 0x43: {
                    code = value;
                    break;
                }
                case 0x4d: {
                    message = value;
                    break;
                }
                default:
                    break;
            }
            ;
            offset = next + 1;
        }
        if (level && code && message) {
            return new protocol_1.DatabaseError(level, code, message);
        }
        throw new Error('Unable to parse error message.');
    }
    receive(buffer, offset, size) {
        const types = this.config.types || null;
        let read = 0;
        while (size >= this.expect + read) {
            let frame = offset + read;
            let mtype;
            // Fast path: retrieve data rows.
            let info = this.activeDataHandlerInfo;
            while (true) {
                mtype = buffer.readInt8(frame);
                if (mtype !== 68 /* RowData */)
                    break;
                if (!info) {
                    throw new Error('No active data handler');
                }
                if (!info.description) {
                    throw new Error('No result type information');
                }
                const bytes = buffer.readInt32BE(frame + 1) + 1;
                if (info) {
                    const total = bytes + read;
                    if (size < total) {
                        this.expect = bytes;
                        return read;
                    }
                    const start = frame + 5;
                    const row = protocol_1.readRowData(buffer, start, info.description, this.encoding, types);
                    // Submit row to result handler.
                    info.handler(row);
                }
                // Keep track of how much data we've consumed.
                read += bytes;
                frame += bytes;
                // If the next message header doesn't fit, we
                // break out and wait for more data to arrive.
                if (size < frame + 5) {
                    this.expect = 5;
                    return read;
                }
            }
            const length = buffer.readInt32BE(frame + 1) - 4;
            const total = length + 5;
            if (size < total + read) {
                this.expect = total;
                break;
            }
            // This is the start offset of the message data.
            const start = frame + 5;
            switch (mtype) {
                case 82 /* Authentication */: {
                    const code = buffer.readInt32BE(start);
                    switch (code) {
                        case 0: {
                            process.nextTick(() => {
                                this.events.connect.emit({});
                            });
                            break;
                        }
                        case 3:
                            this.writer.password(this.config.password || '');
                            break;
                        case 5: {
                            const { user = '', password = '' } = this.config;
                            const salt = buffer.slice(start + 4, start + 8);
                            const shadow = utils_1.md5(`${password}${user}`);
                            this.writer.password(`md5${utils_1.md5(shadow, salt)}`);
                            break;
                        }
                        default:
                            throw new Error(`Unsupported authentication scheme: ${code}`);
                    }
                    break;
                }
                case 75 /* BackendKeyData */: {
                    this.processId = buffer.readInt32BE(start);
                    this.secretKey = buffer.readInt32BE(start + 4);
                    break;
                }
                case 50 /* BindComplete */:
                    {
                        const info = this.bindQueue.shift();
                        this.cleanupQueue.shift(0 /* Bind */);
                        if (info) {
                            this.activeDataHandlerInfo = info;
                        }
                        break;
                    }
                    ;
                case 110 /* NoData */: {
                    this.cleanupQueue.shift(4 /* PreFlight */);
                    const preflight = this.preFlightQueue.shift();
                    if (preflight.dataHandler) {
                        if (preflight.bind) {
                            const info = {
                                handler: preflight.dataHandler,
                                description: null,
                            };
                            this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                        }
                        else {
                            preflight.dataHandler(null);
                        }
                    }
                    else {
                        throw new Error('Data handler not set');
                    }
                    break;
                }
                case 73 /* EmptyQueryResponse */:
                case 67 /* CommandComplete */: {
                    // This is unset if the query had no row data.
                    const info = this.activeDataHandlerInfo;
                    if (info) {
                        const string = buffer.slice(start, start + length - 1).toString();
                        info.handler(string);
                        this.activeDataHandlerInfo = null;
                    }
                    break;
                }
                case 51 /* CloseComplete */:
                    {
                        const handler = this.closeHandlerQueue.shift();
                        this.cleanupQueue.shift(1 /* Close */);
                        if (handler) {
                            handler();
                        }
                        break;
                    }
                    ;
                case 69 /* ErrorResponse */: {
                    const error = this.parseError(buffer.slice(start, start + length));
                    this.events.error.emit(error);
                    loop: while (true) {
                        switch (this.cleanupQueue.shift()) {
                            case 0 /* Bind */: {
                                this.bindQueue.shift();
                                break;
                            }
                            case 1 /* Close */: {
                                this.closeHandlerQueue.shift();
                                break;
                            }
                            case 2 /* ErrorHandler */: {
                                const handler = this.errorHandlerQueue.shift();
                                handler(error);
                                this.error = true;
                                break loop;
                            }
                            case 3 /* ParameterDescription */: {
                                this.parameterDescriptionQueue.shift();
                                break;
                            }
                            case 4 /* PreFlight */:
                                {
                                    this.preFlightQueue.shift();
                                    break;
                                }
                                ;
                            case 5 /* RowDescription */: {
                                this.rowDescriptionQueue.shift();
                                break;
                            }
                        }
                    }
                    break;
                }
                case 78 /* Notice */: {
                    const notice = this.parseError(buffer.slice(start, start + length));
                    this.events.notice.emit(notice);
                    break;
                }
                case 65 /* NotificationResponse */: {
                    const reader = new protocol_1.Reader(buffer, start);
                    const processId = reader.readInt32BE();
                    const channel = reader.readCString(this.encoding);
                    const payload = reader.readCString(this.encoding);
                    this.events.notification.emit({
                        processId: processId,
                        channel: channel,
                        payload: payload
                    });
                    break;
                }
                case 49 /* ParseComplete */:
                    {
                        break;
                    }
                    ;
                case 116 /* ParameterDescription */: {
                    let length = buffer.readInt16BE(start);
                    const types = new Array(length);
                    for (let i = 0; i < length; i++) {
                        const offset = start + 2 + i * 4;
                        const dataType = buffer.readInt32BE(offset);
                        types[i] = dataType;
                    }
                    this.parameterDescriptionQueue.push(types);
                    break;
                }
                case 83 /* ParameterStatus */:
                    {
                        const reader = new protocol_1.Reader(buffer, start);
                        const name = reader.readCString(this.encoding);
                        const value = reader.readCString(this.encoding);
                        this.events.parameter.emit({
                            name: name,
                            value: value
                        });
                        break;
                    }
                    ;
                case 90 /* ReadyForQuery */:
                    {
                        if (this.error) {
                            this.error = false;
                        }
                        else if (this.connected) {
                            this.errorHandlerQueue.shift();
                            this.cleanupQueue.shift(2 /* ErrorHandler */);
                        }
                        else {
                            this.transactionStatus = 73 /* Idle */;
                            this.connecting = false;
                            this.connected = true;
                        }
                        const status = buffer.readInt8(start);
                        this.transactionStatus = status;
                        this.ready = true;
                        this.flush();
                        break;
                    }
                    ;
                case 84 /* RowDescription */:
                    {
                        this.cleanupQueue.shift(4 /* PreFlight */);
                        const preflight = this.preFlightQueue.shift();
                        const description = protocol_1.readRowDescription(buffer, start, this.config.types);
                        preflight.descriptionHandler(description);
                        if (preflight.dataHandler) {
                            const info = {
                                handler: preflight.dataHandler,
                                description: description
                            };
                            if (preflight.bind) {
                                this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                            }
                            else {
                                this.activeDataHandlerInfo = info;
                            }
                        }
                        break;
                    }
                    ;
                default:
                    {
                        logger.warn(`Message not implemented: ${mtype}`);
                        break;
                    }
                    ;
            }
            ;
            this.expect = 5;
            read += total;
        }
        return read;
    }
}
exports.Client = Client;
;
//# sourceMappingURL=client.js.map