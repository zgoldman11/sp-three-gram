"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
const src_1 = require("../src");
const infinity = Number('Infinity');
function getComparisonQueryFor(dataType, expression) {
    switch (dataType) {
        case src_1.DataType.ArrayJson:
            return `select ($1)::jsonb[] <@ (${expression})::jsonb[]`;
        case src_1.DataType.Jsonb:
        case src_1.DataType.Json:
            return `select ($1)::jsonb <@ (${expression})::jsonb`;
        case src_1.DataType.Point:
            return `select $1 ~= ${expression}`;
        default:
            return `select $1 = ${expression}`;
    }
}
function testType(dataType, expression, expected, excludeTextMode = false) {
    const testParam = (format) => {
        helper_1.testWithClient('Param', (client) => __awaiter(this, void 0, void 0, function* () {
            expect.assertions(3);
            const query = expected !== null
                ? getComparisonQueryFor(dataType, expression)
                : 'select $1 is null';
            yield client.query((expected !== null) ? query + ' where $1 is not null' : query, [expected], [dataType], format)
                .then((result) => {
                const rows = result.rows;
                expect(rows.length).toEqual(1);
                expect(rows[0].length).toEqual(1);
                expect(rows[0][0]).toEqual(true);
            });
        }), 250);
    };
    const testValue = (format) => {
        helper_1.testWithClient('Value', (client) => __awaiter(this, void 0, void 0, function* () {
            expect.assertions(3);
            const query = 'select ' + expression;
            yield client.query(query, [], [], format).then((result) => {
                const rows = result.rows;
                expect(rows.length).toEqual(1);
                expect(rows[0].length).toEqual(1);
                expect(rows[0][0]).toEqual(expected);
            });
        }), 250);
    };
    describe(`${expression} (${dataType}/binary)`, () => {
        testParam(src_1.DataFormat.Binary);
        testValue(src_1.DataFormat.Binary);
    });
    if (!excludeTextMode) {
        describe(`${expression} (${dataType}/text)`, () => {
            testParam(src_1.DataFormat.Text);
            testValue(src_1.DataFormat.Text);
        });
    }
}
function utc_date(...rest) {
    return new Date(Date.UTC.apply(null, rest));
}
describe('Types', () => {
    testType(src_1.DataType.Bool, 'true', true);
    testType(src_1.DataType.Bool, 'false', false);
    testType(src_1.DataType.Bpchar, '\'abc\'::char(3)', 'abc');
    testType(src_1.DataType.Bytea, '\'abc\'::bytea', Buffer.from('abc'));
    testType(src_1.DataType.Char, '\'a\'::char(1)', 'a');
    testType(src_1.DataType.Text, '\'a\'::text', 'a');
    testType(src_1.DataType.Int2, '1::int2', 1);
    testType(src_1.DataType.Int4, '1::int4', 1);
    testType(src_1.DataType.Float4, '1::float4', 1.0);
    testType(src_1.DataType.Float8, '1::float8', 1.0);
    testType(src_1.DataType.Oid, '1::oid', 1);
    testType(src_1.DataType.Date, '\'infinity\'::date', infinity);
    testType(src_1.DataType.Date, '\'-infinity\'::date', -infinity);
    testType(src_1.DataType.Date, '\'2000-01-01\'::date', utc_date(2000, 0, 1));
    testType(src_1.DataType.Date, '\'1999-12-31\'::date', utc_date(1999, 11, 31));
    testType(src_1.DataType.Date, '\'1998-12-31\'::date', utc_date(1998, 11, 31));
    testType(src_1.DataType.Date, '\'2001-12-31\'::date', utc_date(2001, 11, 31));
    testType(src_1.DataType.Timestamp, '\'infinity\'::timestamp', infinity);
    testType(src_1.DataType.Timestamp, '\'-infinity\'::timestamp', -infinity);
    testType(src_1.DataType.Timestamptz, '\'2000-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2000, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59.990\'::timestamp at time zone \'utc\'', utc_date(1999, 11, 31, 23, 59, 59, 990));
    testType(src_1.DataType.Timestamptz, '\'1970-01-01 00:00:00.000\'::timestamp at time zone \'utc\'', utc_date(1970, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'2001-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2001, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'2000-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2000, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59.000\'::timestamp at time zone \'utc\'', utc_date(1999, 11, 31, 23, 59, 59, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59Z\'::timestamptz', utc_date(1999, 11, 31, 23, 59, 59));
    testType(src_1.DataType.Timestamptz, '\'1970-01-01 00:00:00Z\'::timestamptz', utc_date(1970, 0, 1, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1893-03-31 22:46:55+00:53:27\'::timestamptz', utc_date(1893, 2, 31, 21, 53, 28));
    testType(src_1.DataType.Date, '\'0002-12-31 BC\'::date', utc_date(-1, 11, 31));
    testType(src_1.DataType.Point, '\'(1,2)\'::Point', { x: 1, y: 2 }, true);
    testType(src_1.DataType.Uuid, '\'123e4567-e89b-12d3-a456-426655440000\'::uuid', '123e4567-e89b-12d3-a456-426655440000');
    testType(src_1.DataType.ArrayInt4, '\'{1,2,3}\'::int4[3]', [1, 2, 3]);
    testType(src_1.DataType.ArrayInt4, '\'{42}\'::int4[3]', [42]);
    testType(src_1.DataType.ArrayInt4, '\'{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}\'::int4[]', [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);
    testType(src_1.DataType.ArrayFloat4, '\'{1.0, 2.0, 3.0}\'::float4[3]', [1.0, 2.0, 3.0]);
    testType(src_1.DataType.ArrayFloat4, '\'{1.125,2.250,3.375}\'::float4[3]', [1.125, 2.250, 3.375]);
    testType(src_1.DataType.ArrayFloat4, '\'{16777217.0}\'::float4[1]', [Math.pow(2, 24)]);
    testType(src_1.DataType.ArrayFloat8, '\'{16777217.0}\'::float8[1]', [Math.pow(2, 24) + 1]);
    testType(src_1.DataType.ArrayVarchar, '\'{abc}\'::varchar[]', ['abc']);
    testType(src_1.DataType.ArrayVarchar, '\'{"\\"abc\\""}\'::varchar[]', ['"abc"']);
    testType(src_1.DataType.ArrayVarchar, '\'{"Ŝќ⽜"}\'::varchar[]', ['Ŝќ⽜']);
    testType(src_1.DataType.ArrayBpchar, '\'{a}\'::bpchar[]', ['a']);
    testType(src_1.DataType.ArrayBytea, '\'{abc}\'::bytea[]', [Buffer.from('abc')]);
    testType(src_1.DataType.ArrayText, '\'{a}\'::text[]', ['a']);
    testType(src_1.DataType.ArrayText, '\'{"a,"}\'::text[]', ['a,']);
    testType(src_1.DataType.ArrayDate, '\'{2000-01-01}\'::date[]', [utc_date(2000, 0, 1)]);
    testType(src_1.DataType.ArrayTimestamp, 'ARRAY[\'infinity\'::timestamp]', [infinity]);
    testType(src_1.DataType.ArrayTimestamptz, 'ARRAY[\'1999-12-31 23:59:59\'::timestamp at time zone \'utc\']', [utc_date(1999, 11, 31, 23, 59, 59)]);
    testType(src_1.DataType.ArrayTimestamptz, '\'{1999-12-31 23:59:59Z}\'::timestamptz[]', [utc_date(1999, 11, 31, 23, 59, 59)]);
    testType(src_1.DataType.Json, '\'{"foo": "bar"}\'::json', { 'foo': 'bar' });
    testType(src_1.DataType.Jsonb, '\'{"foo": "bar"}\'::jsonb', { 'foo': 'bar' });
    testType(src_1.DataType.ArrayJson, 'ARRAY[\'{"foo": "bar"}\'::json]', [{ 'foo': 'bar' }], true);
    // Test nulls
    testType(src_1.DataType.Uuid, 'null', null);
});
//# sourceMappingURL=types.test.js.map