"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
const query_1 = require("../src/query");
const types_1 = require("../src/types");
// Adjust for benchmarking mode.
const benchmarkEnabled = process.env.NODE_ENV === 'benchmark';
const [maxTime, WarmupTime] = (benchmarkEnabled) ?
    [5000, 1000] : [50, 10];
;
function secondsFromHrTime(time) {
    const d = process.hrtime(time);
    return d[0] + d[1] / (Math.pow(10, 9));
}
function unsafeToSimpleQuery(query) {
    let text = query.text;
    const params = (query.values || []).map(String);
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        text = text.replace('$' + (i + 1), param);
    }
    ;
    return new query_1.Query(text);
}
function testSelect(testQuery, batchSize, doReplaceArgs) {
    let { name, query } = (() => {
        switch (testQuery) {
            case 1 /* Array */: return {
                name: 'Array',
                query: new query_1.Query(
                // tslint:disable-next-line
                'select (select array_agg(i) from generate_series(1, 100) as s(i)) from generate_series(1, 100)')
            };
            case 0 /* PgType */: return {
                name: 'PgType',
                query: new query_1.Query(
                // tslint:disable-next-line
                'select typname, typnamespace, typowner, typlen, typbyval, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray from pg_type where typtypmod = $1 and typisdefined = $2', [-1, true])
            };
        }
        ;
    })();
    if (doReplaceArgs) {
        query = unsafeToSimpleQuery(query);
    }
    ;
    helper_1.testWithClient(`SQL: Select (batch size: ${batchSize})`, (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        const go = (time) => __awaiter(this, void 0, void 0, function* () {
            let queries = 0;
            let acknowledged = 0;
            let results = 0;
            let startTime = process.hrtime();
            let secs = time / 1000;
            while (true) {
                const d = secs - secondsFromHrTime(startTime);
                if (d < 0) {
                    break;
                }
                let i = batchSize;
                let promises = [];
                while (i--) {
                    const p = client.query(query).then((result) => {
                        acknowledged += 1;
                        results += result.rows.length;
                    });
                    queries++;
                    promises.push(p);
                }
                yield Promise.all(promises);
            }
            ;
            let d = secondsFromHrTime(startTime);
            return [queries, results, queries - acknowledged, d];
        });
        if (WarmupTime)
            yield go(WarmupTime);
        let [queries, rows, diff, time] = yield go(maxTime);
        let round = (n) => { return Math.round(n / time); };
        if (benchmarkEnabled) {
            const secs = (Math.round(time * 100) / 100).toFixed(2) + ' secs';
            const q = round(queries);
            const r = round(rows);
            console.log(`[${name}] Q/sec: ${q}; ` +
                `R/sec: ${r} (${secs}); ` +
                `B: ${batchSize}`);
        }
        expect(diff).toEqual(0);
    }), (WarmupTime + maxTime) + 10000);
}
;
describe('Events', () => {
    helper_1.testWithClient('End', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        const f = jest.fn();
        client.on('end', f);
        yield client.end();
        expect(f).toBeCalled();
    }));
    helper_1.testWithClient('Connect', (client) => __awaiter(this, void 0, void 0, function* () {
        let p = new Promise((resolve, _) => {
            client.on('connect', () => {
                setTimeout(() => {
                    expect(true).toBeTruthy();
                    resolve();
                }, 125);
            });
        });
        expect.assertions(1);
        return p;
    }));
});
describe('Query', () => {
    helper_1.testWithClient('Without parameters', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        const query = new query_1.Query('select 1');
        const result = yield client.query(query);
        expect(result.rows.length).toEqual(1);
    }));
    helper_1.testWithClient('With parameters', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        const query = new query_1.Query('select $1::int', [1]);
        const result = yield client.query(query);
        expect(result.rows.length).toEqual(1);
    }));
    helper_1.testWithClient('Named portal', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        const query = new query_1.Query('select $1::int', [1]);
        const result = yield client.query(query);
        expect(result.rows.length).toEqual(1);
    }));
    helper_1.testWithClient('Custom value type reader', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(5);
        client.config.types = new Map([
            [types_1.DataType.Int4, (buffer, start, end, format, encoding) => {
                    const value = buffer.readInt32BE(start);
                    expect(end - start).toEqual(4);
                    expect(value).toEqual(1);
                    expect(format).toEqual(types_1.DataFormat.Binary);
                    expect(encoding).toEqual('utf-8');
                    return 1;
                }]
        ]);
        const result = yield client.query('select 1::int4');
        expect(result.rows.length).toEqual(1);
    }));
    helper_1.testWithClient('Prepared statement', (client) => __awaiter(this, void 0, void 0, function* () {
        const count = 5;
        expect.assertions(count * 2);
        yield client.query('prepare test (int) as select $1');
        for (let i = 0; i < count; i++) {
            const result = yield client.query('execute test(1)');
            const rows = result.rows;
            expect(rows.length).toEqual(1);
            expect(rows[0]).toEqual([1]);
        }
    }));
    helper_1.testWithClient('Listen/notify', (client) => __awaiter(this, void 0, void 0, function* () {
        yield client.query('listen foo');
        expect.assertions(2);
        client.on('notification', (msg) => {
            expect(msg.channel).toEqual('foo');
            expect(msg.payload).toEqual('bar');
        });
        yield client.query('notify foo, \'bar\'');
    }));
    helper_1.testWithClient('Cursor', (client) => __awaiter(this, void 0, void 0, function* () {
        yield client.query('begin');
        yield client.query('declare foo cursor for select $1::int4', [1]);
        const result = yield client.query('fetch next from foo');
        expect(result.names).toEqual(['int4']);
        expect(result.rows).toEqual([[1]]);
    }));
    helper_1.testWithClient('Query errors become promise rejection', (client) => __awaiter(this, void 0, void 0, function* () {
        yield expect(client.query('select foo')).rejects.toThrow(/foo/);
    }));
    helper_1.testWithClient('Query errors plays nicely with pipeline', (client) => __awaiter(this, void 0, void 0, function* () {
        const random = (n) => Math.floor(Math.random() * Math.floor(n));
        const make = (n) => {
            switch (n) {
                case 0:
                    {
                        const p = client.query('select foo');
                        return expect(p).rejects.toThrow(/foo/);
                    }
                    ;
                case 1: {
                    const p = client.query('select 1 as i');
                    return expect(p).resolves.toEqual({ names: ['i'], rows: [[1]], status: 'SELECT 1' });
                }
                case 2: {
                    const p = client.query('select 1 / $1 as j', [0]);
                    return expect(p).rejects.toThrow(/division by zero/);
                }
                case 3: {
                    const p = client.query('select $1::int as k', [2]);
                    return expect(p).resolves.toEqual({ names: ['k'], rows: [[2]], status: 'SELECT 1' });
                }
                case 4: {
                    const p = client.query('select $1::internal as l', [""]);
                    return expect(p).rejects.toThrow(/2281/);
                }
            }
            ;
        };
        const go = (remaining) => __awaiter(this, void 0, void 0, function* () {
            if (remaining === 0)
                return Promise.resolve();
            const i = Math.min(Math.max(random(remaining), 1), remaining / 2);
            const promises = [];
            for (let j = 0; j < i; j++) {
                const n = random(5);
                const p = make(n);
                if (p)
                    promises.push(p);
            }
            return Promise.all(promises).then(() => {
                return go(remaining - promises.length);
            });
        });
        for (let i = 0; i < 10; i++) {
            yield go(500);
        }
    }), 5000);
    helper_1.testWithClient('Empty query', (client) => __awaiter(this, void 0, void 0, function* () {
        yield expect(client.query('')).resolves.toEqual({ names: [], rows: [], status: null });
    }));
    helper_1.testWithClient('Unsupported type', (client) => __awaiter(this, void 0, void 0, function* () {
        const text = 'select $1::internal';
        yield expect(client.query(text, [''])).rejects.toThrow(/2281/);
    }));
    helper_1.testWithClient('Prepare and execute', (client) => __awaiter(this, void 0, void 0, function* () {
        const stmt = yield client.prepare('select $1::int as i');
        yield expect(stmt.execute([1])).resolves.toEqual({ names: ['i'], rows: [[1]], status: 'SELECT 1' });
        const result = yield stmt.execute([2]);
        expect(result.rows).toEqual([[2]]);
        yield stmt.close();
    }));
    testSelect(0 /* PgType */, 1, false);
    testSelect(0 /* PgType */, 5, false);
    testSelect(0 /* PgType */, 1, true);
    testSelect(0 /* PgType */, 5, true);
    testSelect(1 /* Array */, 1, false);
    testSelect(1 /* Array */, 5, false);
    testSelect(1 /* Array */, 1, true);
    testSelect(1 /* Array */, 5, true);
});
//# sourceMappingURL=client.test.js.map