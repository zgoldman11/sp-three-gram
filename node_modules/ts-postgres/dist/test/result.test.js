"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
function testIteratorResult(client, f) {
    return __awaiter(this, void 0, void 0, function* () {
        var e_1, _a, e_2, _b;
        const query = () => client.query('select generate_series($1::int, $2::int) as i', [0, 9]);
        const rows = yield f(query());
        expect(rows.length).toEqual(10);
        let expectation = [...Array(10).keys()];
        const keys = rows.map((row) => [...row.names]);
        const values = rows.map((row) => [...row.data]);
        // The get method returns a column using name lookup.
        expect(values).toEqual(rows.map((row) => [row.get('i')]));
        // Keys are column names.
        expect(keys).toEqual(expectation.map(() => ['i']));
        // Values are row values.
        expect(values).toEqual(expectation.map((i) => [i]));
        // We could iterate multiple times over the same result.
        let count = 0;
        const result = query();
        try {
            for (var result_1 = __asyncValues(result), result_1_1; result_1_1 = yield result_1.next(), !result_1_1.done;) {
                const _ = result_1_1.value;
                count += 1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (result_1_1 && !result_1_1.done && (_a = result_1.return)) yield _a.call(result_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        ;
        expect(count).toEqual(10);
        try {
            for (var result_2 = __asyncValues(result), result_2_1; result_2_1 = yield result_2.next(), !result_2_1.done;) {
                const _ = result_2_1.value;
                count += 1;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (result_2_1 && !result_2_1.done && (_b = result_2.return)) yield _b.call(result_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        ;
        expect(count).toEqual(20);
        // The result is also available in the public rows attribute.
        expect(result.rows).toEqual(expectation.map((i) => { return [i]; }));
    });
}
describe('Result', () => {
    helper_1.testWithClient('Names', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(2);
        let result = yield client.query('select $1::text as message', ['Hello world!']);
        expect(result.names.length).toEqual(1);
        expect(result.names[0]).toEqual('message');
    }));
    helper_1.testWithClient('Get', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(3);
        let result = yield client.query('select $1::text as message', ['Hello world!']);
        expect(result.status).toEqual('SELECT 1');
        const rows = [...result];
        const row = rows[0];
        expect(row.get('message')).toEqual('Hello world!');
        expect(row.get('bad')).toEqual(undefined);
    }));
    helper_1.testWithClient('One', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        let row = yield client.query('select $1::text as message', ['Hello world!']).one();
        expect(row.get('message')).toEqual('Hello world!');
    }));
    helper_1.testWithClient('One (empty query)', (client) => __awaiter(this, void 0, void 0, function* () {
        expect.assertions(1);
        yield expect(client.query('select true where false').one())
            .rejects.toThrow(/empty/);
    }));
    helper_1.testWithClient('First (error)', (client) => __awaiter(this, void 0, void 0, function* () {
        const query = client.query('select does-not-exist');
        return expect(query.first()).rejects.toMatchObject({
            message: 'column "does" does not exist'
        });
    }));
    helper_1.testWithClient('One (error)', (client) => __awaiter(this, void 0, void 0, function* () {
        const query = client.query('select does-not-exist');
        return expect(query.one()).rejects.toMatchObject({
            message: 'column "does" does not exist'
        });
    }));
    helper_1.testWithClient('Synchronous iteration', (client) => __awaiter(this, void 0, void 0, function* () {
        yield testIteratorResult(client, (p) => __awaiter(this, void 0, void 0, function* () {
            return p.then((result) => {
                const rows = [];
                for (const row of result) {
                    rows.push(row);
                }
                ;
                return rows;
            });
        }));
    }));
    helper_1.testWithClient('Asynchronous iteration', (client) => __awaiter(this, void 0, void 0, function* () {
        yield testIteratorResult(client, (result) => { var result_3, result_3_1; return __awaiter(this, void 0, void 0, function* () {
            var e_3, _a;
            const rows = [];
            try {
                for (result_3 = __asyncValues(result); result_3_1 = yield result_3.next(), !result_3_1.done;) {
                    const row = result_3_1.value;
                    rows.push(row);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (result_3_1 && !result_3_1.done && (_a = result_3.return)) yield _a.call(result_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            ;
            return rows;
        }); });
    }));
});
//# sourceMappingURL=result.test.js.map