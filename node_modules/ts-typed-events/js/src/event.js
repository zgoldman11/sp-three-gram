"use strict";
/** This is a very simple strongly typed event emitter class, see README.md for more details */
Object.defineProperty(exports, "__esModule", { value: true });
/** A typed event, given a type will emit values of that type to listeners */
var Event = /** @class */ (function () {
    function Event() {
        /** All the current listeners for this event */
        this.listeners = [];
    }
    /**
     * Attaches a listener to trigger on all emits for this event
     * @param callback the callback to invoke on all emits
     */
    Event.prototype.on = function (callback) {
        this.listeners.push({
            once: false,
            callback: callback,
        });
    };
    /**
     * Attaches a listener to trigger on only the first emit for this event.
     *
     * This version either takes a callback or returns a promise.
     * @param callback optional callback, if specified invokes the callback
     * only once when the event is triggered, then removes it.
     * Otherwise returns a promise that resolves with the value the next time
     * this event is triggered
     */
    Event.prototype.once = function (callback) {
        var _this = this;
        if (!callback) {
            // then they want us to return the promise
            var promise = new Promise(function (resolve, reject) {
                // this will invoke the version that has a callback, so resolve can be used as the callback
                _this.once(resolve);
            });
            // attach the promise we just made to the listener (it was pushed on
            // the end via this.once() above)
            this.listeners[this.listeners.length - 1].promise = promise;
            return promise;
        }
        // else we were sent a normal callback, so attach it
        this.listeners.push({
            once: true,
            callback: callback,
        });
    };
    /**
     * Removes a callback from the listeners on this event, regardless of once vs on.
     *
     * Returns true if a callback was removed, false otherwise.
     * @param callback The callback to remove
     * @returns true if a callback was removed, false otherwise
     */
    Event.prototype.off = function (listener) {
        var originalLength = this.listeners.length;
        // remove all listeners that have the same callback as this one
        this.listeners = this.listeners.filter(function (l) {
            return listener !== l.callback && (!l.promise || listener !== l.promise);
        });
        return this.listeners.length !== originalLength;
    };
    /**
     * Removes ALL callbacks from this event, regardless of once vs on.
     *
     * Returns the number of listeners removed.
     * @returns The number of listeners removed
     */
    Event.prototype.offAll = function () {
        var originalLength = this.listeners.length;
        this.listeners.length = 0; // empty our listener array
        return originalLength;
    };
    /**
     * Emits a value to all the listeners, triggering their callbacks.
     *
     * Returns true if the event had listeners, false otherwise.
     * @param arg The argument to emit to all listeners as their argument.
     * @returns true if the event had listeners, false otherwise
     */
    Event.prototype.emit = function (arg) {
        var hadListeners = this.listeners.length > 0;
        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener.callback(arg);
        }
        // remove all listeners that only wanted to listen once
        this.listeners = this.listeners.filter(function (l) { return !l.once; });
        return hadListeners;
    };
    return Event;
}());
exports.Event = Event;
//# sourceMappingURL=event.js.map